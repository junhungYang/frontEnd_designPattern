<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>设计模式六大原则</title>
</head>
<body>
    <script>
        //  什么是设计模式，原则
        //  设计模式是一套反复使用，多数人知晓的，经过分类的代码设计经验的总结

        //  目的
        //  为了代码可重用性，让代码更容易被他人理解，保证代码可靠性。

        //  模式
        //  指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。模式即解决某一类问题的方法论。

        //  创建型设计模式 --> 用于研究如何高效地创建对象
        //  1. 单例模式
        //  2. 抽象工厂模式
        //  3. 建造者模式
        //  4. 工厂模式
        //  5. 原型模式

        //  结构性设计模式  --> 用于设计对象的结构与关系
        //  1. 适配器模式
        //  2. 桥接模式
        //  3. 装饰模式
        //  4. 组合模式
        //  5. 外观模式
        //  6. 享元模式
        //  7. 代理模式

        // 行为型设计模式  --> 设计对象的行为
        // 模版方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，
        // 解释器模式，状态模式，策略模式，职责链模式，访问者模式
        

        // 设计模式的基本标准
        // 降低代码的复杂程度，合理地减少耦合度，复杂程度与耦合度影响开发维护拓展成本

        // 耦合的定义
        // 耦合关系是指两个事物之间存在一种直接的相互作用，相互影响的关系，这种关系即耦合关系

        // 耦合度和复杂度的危害
        // 复杂度：高，代码质量不高，可维护性差，复用性差，不易拓展
        // 耦合度：无 不可能，低 合理，过高不容易维护。但依然是有复用性和拓展性，但复用性与拓展性不一定会非常好


        // 复杂度与耦合度的权衡
        // 复杂度与耦合度一定程度上存在相互制约的关系，复杂度高可以使耦合度变低，例如把一堆逻辑全写在一个函数上
        // 或是手写创建多个长得差不多的对象等等，而通过提高耦合度，可使逻辑的分工更清晰，在创建对象方面提取共性，再去定制个性

        // 准则：优先降低复杂度，尽量降低耦合度
        // 1. 利用单一职责原则，开闭原则，里氏代换原则提高耦合度，从而降低复杂度
        // 2. 通过迪米特法则减少耦合
        // 3. 通过依赖倒置原则消除没有必要的耦合(可使用环境相对狭窄)

        // 设计模式六大原则
        // 1. 单一职责原则(一个方法只做一件事情，请求数据的函数你就不要渲染数据了，吃饭上厕所别用同一个地方)

        // 2. 开闭原则(OCP)
        //  一个软件实体如类，模块和函数应该对拓展开放，对修改关闭，如闭包，jquery中的extend方法，同时增强代码复用性

        // 3. 里氏代换原则(针对拓展)
        //  任何基类可以出现的地方，子类一定可以出现，举个例子：只要存在一个基类对象，就可以通过原型链继承的方式创建一个该基类的子类对象，
        //  在继承基类方法与属性的同时添加子类独有的方法。
        //  而里氏代换原则阐述的即是，子类可以通过定制自己的功能，从而拓展父类加子类的总功能，但不能直接或间接的改变父类原有功能，
        //  其中一原因是该父类可能有其他子类，而当另一子类为了创建自己的特性而直接改变了父类的某一功能时，其他子类也会可能因此被牵连而改变，
        //  亦或者某一子类为了创建自己的特性而间接改变了父类的某一功能时，本来适用于所有子类的父类方法，变得不再适用于该特定子类
        // 案例
        {   
            //矩形
            function Rectangle () {
                this.width = 0
                this.height = 0
                this.setWidth = function (width) {
                    this.width = width
                }
                this.setHeight = function (height) {
                    this.height = height
                }
                this.getWidth = function () {
                    return this.width
                }
                this.getHeight = function () {
                    return this.height
                }
            }
            // 正方形，正方形也属于矩形，所以它属于矩形的子类
            Square.prototype = new Rectangle()
            function Square () {
                // 间接重写了父类的功能
                this.setWidth = function (width) {
                    this.width = width
                    this.height = width
                }
                this.setHeight = function (height) {
                    this.setWidth(height)
                }
            }
            let oR = new Rectangle()
            oR.setWidth(100)
            oR.setHeight(200)
            let oS = new Square()
            oS.setWidth(150)
            // 需求: 四边形的宽每次+1，当宽大于高时打印over
            function changeWidth (o) {
                while(o.getHeight() >= o.getWidth()) {
                    o.setWidth(o.getWidth()+1)
                }
                console.log('over',o)
            }
            changeWidth(oR)
            // changeWidth(oS)

            // 当传入changeWidth的对象为oR时，程序可以很正常地执行
            // 当传入oS时形成了死循环，原因在于当setWidth时，高也同时被改变，宽与高将用于处于相等的状态，导致永远跳不出while循环，
            // 这就是里氏代换原则所阐述的观点，对基类进行拓展可以，但不可以改变基类的功能。
        }
        

        // 4. 迪米特法则(最小之道原则)
        //  一个接口和一个方法，传入的参数或与其他函数的关联越少越好，降低耦合度的同时也会让复杂度降低，当一个函数需要传入多个参数时，
        //  函数体内的判断必然变得复杂，同时其中一个参数出错也可能导致整个方法出现错误，或一个函数与其他的函数的关联很多时，牵一发而动全身
        //  整体的逻辑将会变得不稳定，其次维护拓展也困难


        // 5. 依赖导致原则
        //  最常用的原则，依赖接口，不依赖方法，js中没有接口的概念，在java中，接口即父类提供一个盒子，该盒子只有名字里面任何东西都没有，
        //  事先监听着该盒子，当一个方法往该盒子里装入东西时，监听到盒子里的东西发生变化，从而使另一方法执行，即借助一个中间量，消除方法与方法间的耦合
        //  因为此时两个方法都不再依赖对方而只是依赖一个中间量。
        //  这与vuex的原理相似   state管理着一堆接口，同时在组件里可以通过watch监听这些接口的变化，当一个方法改变了某一state,watch监听到该state的变化
        //  从而触发另一方法，耦合仅限于两个方法间直接产生关联的情概，而在vuex中两个方法之间不产生任何直接关联，它们都只是依赖一个状态而已，这种情况不称为耦合


        // 6.接口分离原则
        //  把大接口拆分为小接口，不能一个接口全部实现增删改查。


        // 总结
        // 先原则，再模式，原则是理论，模式是在理论上的具体方式。
    </script>
</body>
</html>